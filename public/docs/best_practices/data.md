# Data normalization

Both, Redux and Melody, work best if you use immutable data.

Using this approach greatly helps with performance improvements and allows
us to write highly testable and maintainable code.

It does, however, come with a price: Memory usage.
Every change of your application will cause objects to be discarded and
new ones to be created. Compared to the amount of Garbage generated by
throwing away large DOM subtrees, that cost is not relevant. There are,
however, techniques you can use to limit or optimize memory usage without
decreasing performance.

The most efficient of which is *data normalization*.

Let's take a look at a practical example of a badly structured data layer
and how we can optimize it to be 

```json
{
    "items": [
        {
            "id": "12387",
            "name": "Best Western",
            "bestPrice": {
                "price": "$79",
                "partner": "Booking.com"
            }
        },
        {
            "id": "986321",
            "name": "Hilton",
            "bestPrice": {
                "price": "$129",
                "partner": "Booking.com"
            }
        }
    ]
}
```

With that structure, every time the `bestPrice` of an item changes, you'll
have to create a copy of the hotel and the entire `items` array.

To avoid that problem, we can modify the structure so that an item only
has a link to its best deal:

```json
{
    "items": [
        {
            "id": "12387",
            "name": "Best Western"
        },
        {
            "id": "986321",
            "name": "Hilton"
        }
    ],
    "bestPrices": {
        "12387": {
            "price": "$79",
            "partner": "Booking.com"
        },
        "986321": {
            "price": "$129",
            "partner": "Booking.com"
        }
    }
}
```

This way, changing a price won't cause the items themselves to be modified
and allows us to change the specific part of the data that actually changed.
If we are absolutely sure that no part of the UI ever uses the `bestPrices`
field directly and that it isn't used to identify changes, we can even treat
it as mutable and limiting the immutability to the actual `bestPrice` objects.

The `mapStateToProps` converter from [trv-melody/redux](./connect.md) would
then provide the data in the required format for the UI.
